---
phase: 01-hook-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Makefile
  - lib/header.sh
  - lib/env.sh
  - lib/compat.sh
  - lib/hooks.sh
  - vendor/bash-preexec.sh
  - tests/test_hooks.sh
autonomous: true
requirements: [HOOK-01, HOOK-02, HOOK-03]

must_haves:
  truths:
    - "Sourcing better-shell.sh in bash registers _bsh_preexec and _bsh_precmd hooks"
    - "Sourcing better-shell.sh in zsh registers _bsh_preexec and _bsh_precmd hooks via add-zsh-hook"
    - "precmd captures exit code as first operation (exit code is not clobbered)"
    - "preexec records command start time and command string"
    - "Non-interactive shells (bash -c, piped) skip all hook registration silently"
    - "SSH sessions are blocked by default unless _BSH_SSH_ENABLED=1"
    - "CI environments (CI, GITHUB_ACTIONS, JENKINS_URL vars) are blocked"
    - "Double-sourcing is a no-op (idempotency guard)"
  artifacts:
    - path: "lib/header.sh"
      provides: "Version, idempotency guard, _BSH_DIR setup"
      contains: "_BSH_LOADED"
    - path: "lib/env.sh"
      provides: "Environment detection (interactive, SSH, CI)"
      exports: ["_bsh_is_interactive"]
    - path: "lib/compat.sh"
      provides: "Shell detection, bash-preexec sourcing for bash, add-zsh-hook for zsh"
      contains: "_BSH_SHELL"
    - path: "lib/hooks.sh"
      provides: "preexec and precmd hook implementations"
      exports: ["_bsh_preexec", "_bsh_precmd"]
    - path: "vendor/bash-preexec.sh"
      provides: "Bundled bash-preexec 0.6.0"
    - path: "Makefile"
      provides: "Build system: cat vendor + lib into better-shell.sh"
  key_links:
    - from: "lib/compat.sh"
      to: "vendor/bash-preexec.sh"
      via: "sources bash-preexec when _BSH_SHELL is bash"
      pattern: "source.*bash-preexec"
    - from: "lib/hooks.sh"
      to: "preexec_functions/precmd_functions arrays"
      via: "hook registration at end of compat.sh"
      pattern: "preexec_functions\\+=\\|add-zsh-hook preexec"
    - from: "lib/hooks.sh"
      to: "exit code capture"
      via: "_bsh_precmd first line"
      pattern: "local _bsh_exit=\\$\\?"
---

<objective>
Create the core hook infrastructure: environment detection, shell compatibility layer, and preexec/precmd hook implementations for both bash and zsh.

Purpose: This is the foundation all future phases build on. Every reactive behavior (audio, visuals, triggers) depends on reliable command start/end/exit-code detection.
Output: lib/ source files, vendored bash-preexec, Makefile, and a test script that validates hook behavior.
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-hook-infrastructure/01-CONTEXT.md
@.planning/phases/01-hook-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold project and create environment detection + shell compat layer</name>
  <files>
    Makefile
    lib/header.sh
    lib/env.sh
    lib/compat.sh
    vendor/bash-preexec.sh
  </files>
  <action>
    Create the project directory structure and core infrastructure files:

    **Makefile:**
    - `make build` target: concatenates `vendor/bash-preexec.sh` then `lib/header.sh lib/env.sh lib/compat.sh lib/hooks.sh lib/toggle.sh lib/config.sh` into `better-shell.sh`
    - `make clean` target: removes `better-shell.sh`
    - Use variables for file lists so Plan 02 files (toggle.sh, config.sh) are already in the recipe but missing files are tolerated (use wildcard or list all — they will exist after Plan 02)

    **lib/header.sh:**
    - Idempotency guard: `[[ -n "${_BSH_LOADED:-}" ]] && return 0` then `_BSH_LOADED=1`
    - Set `_BSH_DIR="${_BSH_DIR:-${HOME}/.better-shell}"`
    - Set `_BSH_VERSION="0.1.0"`
    - Initialize `_BSH_ENABLED=1` (default on)
    - Initialize `_BSH_SSH_ENABLED=0` (default SSH off)

    **lib/env.sh:**
    - Define `_bsh_is_interactive()` function with these checks in order:
      1. `[[ $- == *i* ]] || return 1` — not interactive
      2. `[[ -t 1 ]] || return 1` — no TTY
      3. SSH check: if `SSH_TTY` or `SSH_CLIENT` is set, return 1 unless `_BSH_SSH_ENABLED == 1`
      4. CI check: if `CI`, `GITHUB_ACTIONS`, or `JENKINS_URL` is set, return 1
      5. Return 0
    - Call `_bsh_is_interactive || return 0` immediately after defining it (this gates all subsequent code)

    **lib/compat.sh:**
    - Shell detection: check `ZSH_VERSION` then `BASH_VERSION`, set `_BSH_SHELL` variable. If neither, `return 0` silently.
    - Zsh path: `autoload -Uz add-zsh-hook` (hook registration happens in hooks.sh)
    - Bash path: source bash-preexec. Since we concatenate at build time, bash-preexec code is already above in the file. Just verify `__bp_install` or `preexec_functions` exists; if not, log warning and return 0. During development (sourcing lib files individually), provide a fallback: `source "${_BSH_DIR}/vendor/bash-preexec.sh" 2>/dev/null`
    - Add `emulate -L zsh` guard comment for zsh hook functions (actual guard goes in hooks.sh)

    **vendor/bash-preexec.sh:**
    - Download bash-preexec v0.5.0 (latest stable) from https://raw.githubusercontent.com/rcaloras/bash-preexec/master/bash-preexec.sh
    - Use `curl` or `wget` to fetch it. If download fails, create a placeholder with a comment explaining manual download needed.
    - Pin the version with a comment at the top of the file noting the source URL and date.
  </action>
  <verify>
    <automated>cd /home/maxi/Documents/coding/Projects/Better-Shell && test -f Makefile && test -f lib/header.sh && test -f lib/env.sh && test -f lib/compat.sh && test -f vendor/bash-preexec.sh && grep -q "_BSH_LOADED" lib/header.sh && grep -q "_bsh_is_interactive" lib/env.sh && grep -q "_BSH_SHELL" lib/compat.sh && echo "PASS: All scaffold files exist with expected content"</automated>
  </verify>
  <done>
    Makefile exists with build/clean targets. lib/header.sh has idempotency guard and variable init. lib/env.sh has _bsh_is_interactive() with interactive, TTY, SSH, and CI checks. lib/compat.sh detects bash vs zsh and sets up bash-preexec sourcing. vendor/bash-preexec.sh is downloaded and pinned.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement preexec/precmd hooks and hook registration</name>
  <files>
    lib/hooks.sh
  </files>
  <action>
    Create lib/hooks.sh with the hook implementations and registration:

    **_bsh_preexec() function:**
    - Guard: `[[ $_BSH_ENABLED == 1 ]] || return 0`
    - For zsh: add `emulate -L zsh` as first line (before guard) to ensure clean zsh option state
    - Record `_BSH_CMD_START_TIME=$SECONDS`
    - Record `_BSH_LAST_CMD="${1:-}"` (both bash-preexec and zsh pass the command string as $1)

    **_bsh_precmd() function:**
    - CRITICAL: `local _bsh_exit=$?` MUST be the very first line — before guard, before anything else
    - For zsh: `emulate -L zsh` should come AFTER exit code capture (since emulate resets $?)
    - Wait, correction: `emulate -L zsh` does NOT reset $? in practice when used with local. To be safe, capture exit code first, then emulate:
      ```
      local _bsh_exit=$?
      # emulate -L zsh  # Only needed if called from unusual context; skip for safety since it could affect $?
      ```
    - Guard: `[[ $_BSH_ENABLED == 1 ]] || return 0`
    - Store: `_BSH_LAST_EXIT=$_bsh_exit`
    - Calculate duration: `_BSH_CMD_DURATION=$(( SECONDS - ${_BSH_CMD_START_TIME:-$SECONDS} ))`
    - Reset start time: `_BSH_CMD_START_TIME=$SECONDS`
    - Comment: "Phase 2+ will act on _BSH_LAST_EXIT and _BSH_CMD_DURATION here"

    **Hook registration (at bottom of file):**
    - Zsh: `add-zsh-hook preexec _bsh_preexec` and `add-zsh-hook precmd _bsh_precmd`
    - Bash: `preexec_functions+=(_bsh_preexec)` and `precmd_functions+=(_bsh_precmd)`
    - Use `if [[ "$_BSH_SHELL" == "zsh" ]]; then ... else ... fi` to dispatch

    **Important implementation notes:**
    - All internal variables use `_BSH_` prefix (uppercase) for globals, `_bsh_` prefix (lowercase) for functions
    - No `echo`, `printf`, or any stdout/stderr output from hook functions — ever
    - The hook functions must be lightweight: no subshells, no external commands, no file I/O
  </action>
  <verify>
    <automated>cd /home/maxi/Documents/coding/Projects/Better-Shell && test -f lib/hooks.sh && grep -q "_bsh_preexec" lib/hooks.sh && grep -q "_bsh_precmd" lib/hooks.sh && grep -q 'local _bsh_exit=\$?' lib/hooks.sh && grep -q "_BSH_CMD_START_TIME" lib/hooks.sh && grep -q "add-zsh-hook\|preexec_functions" lib/hooks.sh && echo "PASS: hooks.sh has preexec, precmd, exit capture, and registration"</automated>
  </verify>
  <done>
    lib/hooks.sh contains _bsh_preexec (records start time + command), _bsh_precmd (captures exit code as first operation, calculates duration), and conditional hook registration for both bash and zsh. No output is produced by any hook function.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration test script for hook behavior</name>
  <files>
    tests/test_hooks.sh
  </files>
  <action>
    Create tests/test_hooks.sh — a bash script that validates the hook infrastructure works correctly. This is a self-contained test runner (not a test framework dependency).

    **Test structure:**
    - Define helper: `_test_pass(name)` and `_test_fail(name, reason)` that print TAP-style output (ok/not ok)
    - Track pass/fail counts, exit 1 if any failures

    **Test cases:**

    1. **Idempotency guard:** Source lib/header.sh twice, verify _BSH_LOADED is set and second source is no-op (check that _BSH_VERSION is still "0.1.0", not re-initialized)

    2. **Environment detection — interactive:** In the test script itself, `$-` won't contain `i` (it's a script, not interactive). Verify `_bsh_is_interactive` returns 1 (non-interactive correctly detected). This is a positive test that the guard works.

    3. **Environment detection — CI variable:** Set `CI=true`, source env.sh, verify `_bsh_is_interactive` returns 1.

    4. **Environment detection — SSH:** Set `SSH_TTY=/dev/pts/0`, verify `_bsh_is_interactive` returns 1. Then set `_BSH_SSH_ENABLED=1`, verify it returns 0 (if also interactive — this test may need to be adjusted since the script is non-interactive).

    5. **Shell detection:** Verify `_BSH_SHELL` is set to "bash" (since tests run in bash).

    6. **Hook functions exist:** Verify `_bsh_preexec` and `_bsh_precmd` are defined as functions (use `type _bsh_preexec`).

    7. **Exit code capture:** Call `_bsh_precmd` after running `false` (exit code 1). Verify `_BSH_LAST_EXIT` equals 1. Call after `true`, verify equals 0.

    8. **Preexec records command:** Call `_bsh_preexec "ls -la"`. Verify `_BSH_LAST_CMD` equals "ls -la".

    9. **Duration tracking:** Set `_BSH_CMD_START_TIME` to `$(( SECONDS - 5 ))`, call `_bsh_precmd`, verify `_BSH_CMD_DURATION` is approximately 5 (>= 4 and <= 6).

    10. **Enabled guard:** Set `_BSH_ENABLED=0`, call `_bsh_preexec "test"`, verify `_BSH_LAST_CMD` was NOT updated (still old value). Reset `_BSH_ENABLED=1`.

    **Important:** Since the test script is non-interactive, it cannot test the full source flow (env.sh will bail). Instead:
    - Source each lib file directly in the right order for function-level testing
    - Skip the `_bsh_is_interactive || return 0` call in env.sh by sourcing only the function definition (or by pre-setting `_BSH_ENABLED=1` and defining the function, then testing it separately)
    - Use `bash -c` with explicit interactive flags where needed, or simply test functions in isolation

    Add a `make test` target to Makefile that runs `bash tests/test_hooks.sh`.
  </action>
  <verify>
    <automated>cd /home/maxi/Documents/coding/Projects/Better-Shell && bash tests/test_hooks.sh</automated>
  </verify>
  <done>
    tests/test_hooks.sh runs all test cases and prints TAP-style output. `make test` runs the test suite. All tests pass: idempotency guard works, environment detection correctly identifies non-interactive/CI/SSH contexts, hook functions exist and capture exit codes correctly, duration tracking works, enabled guard prevents hook execution when disabled.
  </done>
</task>

</tasks>

<verification>
1. All lib files exist: header.sh, env.sh, compat.sh, hooks.sh
2. vendor/bash-preexec.sh is present
3. Makefile has build and clean targets
4. `bash tests/test_hooks.sh` passes all test cases
5. No file produces any stdout/stderr output when sourced in non-interactive context
</verification>

<success_criteria>
- lib/ directory contains header.sh, env.sh, compat.sh, hooks.sh with correct implementations
- vendor/bash-preexec.sh is bundled
- Hook functions (_bsh_preexec, _bsh_precmd) correctly capture exit code, command string, and duration
- Environment detection blocks non-interactive, CI, and SSH (by default) contexts
- Idempotency guard prevents double-loading
- All tests pass via `make test`
</success_criteria>

<output>
After completion, create `.planning/phases/01-hook-infrastructure/01-01-SUMMARY.md`
</output>
