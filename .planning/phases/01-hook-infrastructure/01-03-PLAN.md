---
phase: 01-hook-infrastructure
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Makefile
  - better-shell.sh
autonomous: true
requirements: [HOOK-01, HOOK-02, HOOK-03, HOOK-04]
gap_closure: true

must_haves:
  truths:
    - "Sourcing better-shell.sh in zsh loads all lib code and registers hooks"
    - "Sourcing better-shell.sh in bash continues to work identically"
    - "_BSH_LAST_EXIT is populated after running any command in zsh"
    - "All 12 UAT tests pass in both bash and zsh"
  artifacts:
    - path: "Makefile"
      provides: "build target that wraps bash-preexec in a function guard"
      contains: "_bsh_load_bash_preexec"
    - path: "better-shell.sh"
      provides: "Rebuilt distributable with guarded bash-preexec section"
      contains: "_bsh_load_bash_preexec"
  key_links:
    - from: "better-shell.sh (bash-preexec section)"
      to: "lib/header.sh and all subsequent lib code"
      via: "bash-preexec wrapped in function so its return 1 cannot exit the sourced file"
      pattern: "_bsh_load_bash_preexec"
---

<objective>
Fix the zsh early-exit bug: bash-preexec's `return 1` (line 42) aborts the entire concatenated better-shell.sh when sourced in zsh. Wrap bash-preexec in a loader function during the build so its early returns are scoped to the function, not the file.

Purpose: All 9 skipped UAT tests are blocked by this one root cause. Fixing it restores zsh hook registration, exit code capture, command recording, and bsh toggle — all the work from Plans 01 and 02 that already works in bash.
Output: Updated Makefile with a wrapper build step, rebuilt better-shell.sh that loads fully in both bash and zsh.
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-hook-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-hook-infrastructure/01-02-SUMMARY.md

<interfaces>
<!-- Root cause: vendor/bash-preexec.sh lines 41-43 in the concatenated file -->
<!-- When better-shell.sh is sourced in zsh, this block fires at file scope: -->
```bash
if [ -z "${BASH_VERSION-}" ]; then
    return 1   # <-- exits the entire sourced file, not a function
fi
```
<!-- Everything after line 43 in better-shell.sh is never reached in zsh. -->
<!-- lib/header.sh, lib/env.sh, lib/compat.sh, lib/hooks.sh, lib/toggle.sh never load. -->

<!-- Current Makefile build target (line 22): -->
```makefile
build:
	cat $(VENDOR) $(EXISTING_LIB) > $(DIST)
```

<!-- Current concatenation order: -->
<!-- vendor/bash-preexec.sh, lib/header.sh, lib/config.sh, lib/env.sh, -->
<!-- lib/compat.sh, lib/hooks.sh, lib/toggle.sh -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap bash-preexec in a loader function during build and rebuild distributable</name>
  <files>
    Makefile
    better-shell.sh
  </files>
  <action>
    The problem: `return 1` at file scope in bash-preexec exits the entire sourced file in zsh.
    The fix: wrap bash-preexec content in a shell function so `return` only exits the function.

    **Update the Makefile `build` target** to produce a wrapped bash-preexec section instead of
    raw concatenation. Replace the current single `cat` line with a multi-step build:

    ```makefile
    build:
    	@printf '# bash-preexec loader — bash only; wrapped so return cannot exit the sourced file\n' > $(DIST)
    	@printf '_bsh_load_bash_preexec() {\n' >> $(DIST)
    	@cat $(VENDOR) >> $(DIST)
    	@printf '\n}\n' >> $(DIST)
    	@printf '[ -n "${BASH_VERSION-}" ] && _bsh_load_bash_preexec\n' >> $(DIST)
    	@printf 'unset -f _bsh_load_bash_preexec 2>/dev/null\n\n' >> $(DIST)
    	@cat $(EXISTING_LIB) >> $(DIST)
    ```

    This produces a better-shell.sh whose first ~350 lines are:
    ```bash
    # bash-preexec loader — bash only; wrapped so return cannot exit the sourced file
    _bsh_load_bash_preexec() {
      # ... full bash-preexec content (vendor/bash-preexec.sh) ...
    }
    [ -n "${BASH_VERSION-}" ] && _bsh_load_bash_preexec
    unset -f _bsh_load_bash_preexec 2>/dev/null

    # lib/header.sh content follows ...
    # lib/config.sh content follows ...
    # lib/env.sh content follows ...
    # lib/compat.sh content follows ...
    # lib/hooks.sh content follows ...
    # lib/toggle.sh content follows ...
    ```

    Why this works:
    - In zsh: `BASH_VERSION` is empty, so `_bsh_load_bash_preexec` is never called. The function
      is defined and immediately unset. All lib code below loads normally.
    - In bash: `_bsh_load_bash_preexec()` is called. Inside the function, `return 1` and `return 0`
      only exit the function scope. bash-preexec initializes correctly. `preexec_functions` and
      `precmd_functions` are registered. lib code loads normally.
    - The `unset -f` on the loader function is a cleanup step — it removes the wrapper artifact
      from the shell namespace after bash-preexec is loaded. Use `2>/dev/null` to silence any
      error if the function was never defined (zsh path).

    **After updating the Makefile**, run:
    ```bash
    make clean && make build
    ```

    **Verify the built file structure** by checking the first 20 lines of better-shell.sh:
    - Line 1 should be the `# bash-preexec loader` comment
    - Lines 2+ should be `_bsh_load_bash_preexec() {`
    - After the closing `}`, there should be the conditional call and unset
    - After that, lib/header.sh content (look for `_BSH_LOADED`)

    Also verify bash-preexec's early-return lines are now inside the function body, not at
    file scope. The pattern `if [ -z "${BASH_VERSION-}" ]` must appear INSIDE the function
    definition, not at top level.
  </action>
  <verify>
    <automated>
      cd /home/maxi/Documents/coding/Projects/Better-Shell && make clean && make build && grep -n "_bsh_load_bash_preexec" better-shell.sh | head -5 && grep -n "_BSH_LOADED" better-shell.sh | head -3 && echo "--- Structure check: bash-preexec return must be inside function ---" && awk '/^_bsh_load_bash_preexec\(\)/{inside=1} inside && /return 1/{print NR": "$0; found=1} /^}/{inside=0} END{if(!found){print "FAIL: return 1 not found inside function"}}' better-shell.sh | head -5
    </automated>
  </verify>
  <done>
    Makefile build target wraps vendor/bash-preexec.sh in `_bsh_load_bash_preexec()` and calls it
    conditionally on BASH_VERSION. better-shell.sh is rebuilt: bash-preexec section is a function
    definition, lib/header.sh content (with `_BSH_LOADED`) appears after the function block.
    The early `return 1` from bash-preexec is inside the function body, not at file scope.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate fix in both shells and confirm all unit tests still pass</name>
  <files></files>
  <action>
    Run the existing test suite to confirm the bash path is unbroken, then perform targeted zsh
    smoke tests to confirm the fix works.

    **Step 1 — Run the full unit test suite (bash):**
    ```bash
    make test
    ```
    All tests in tests/test_hooks.sh and tests/test_toggle.sh must still pass. These run in bash
    and validate the logic layer. If any test regresses, the Makefile change broke something in
    the bash build path — investigate before proceeding.

    **Step 2 — Zsh smoke test for hook registration:**
    Run a zsh subshell that sources better-shell.sh and checks whether the hooks loaded:
    ```bash
    zsh -i -c '
      source ./better-shell.sh
      if typeset -f _bsh_precmd > /dev/null 2>&1; then
        echo "PASS: _bsh_precmd defined in zsh"
      else
        echo "FAIL: _bsh_precmd not defined in zsh"
        exit 1
      fi
      if typeset -f bsh > /dev/null 2>&1; then
        echo "PASS: bsh function defined in zsh"
      else
        echo "FAIL: bsh function not defined in zsh"
        exit 1
      fi
    ' 2>&1
    ```

    Note: `zsh -i -c` creates an interactive zsh subshell. The `-i` flag sets `$-` to include
    `i`, satisfying the `_bsh_is_interactive` check. Without `-i`, env.sh's gate would block
    loading — this is correct behavior, not a bug.

    **Step 3 — Zsh smoke test for exit code capture:**
    ```bash
    zsh -i -c '
      source ./better-shell.sh
      false
      if [[ -n "${_BSH_LAST_EXIT}" ]]; then
        echo "PASS: _BSH_LAST_EXIT=${_BSH_LAST_EXIT}"
      else
        echo "FAIL: _BSH_LAST_EXIT is empty after false"
        exit 1
      fi
    ' 2>&1
    ```

    Note on precmd timing: `_bsh_precmd` fires before each prompt, triggered by zsh's precmd hook.
    In a `zsh -i -c '...'` one-liner, there may not be a prompt cycle between `false` and the
    if-check. If _BSH_LAST_EXIT is empty in the subshell test, that is a test harness limitation
    — NOT a bug. The real-world fix is confirmed if Step 2 passes (hooks are defined). Document
    this limitation in the plan output if encountered.

    **Step 4 — Bash regression check (source at file scope):**
    ```bash
    bash -i -c '
      source ./better-shell.sh
      if typeset -f _bsh_precmd > /dev/null 2>&1; then
        echo "PASS: _bsh_precmd defined in bash"
      else
        echo "FAIL: _bsh_precmd not defined in bash"
        exit 1
      fi
      if declare -p preexec_functions > /dev/null 2>&1; then
        echo "PASS: preexec_functions array exists in bash"
      else
        echo "FAIL: preexec_functions not set in bash"
        exit 1
      fi
    ' 2>&1
    ```

    All four steps must produce only PASS lines. If Step 3 fails due to the precmd timing
    limitation (documented above), that is acceptable — note it in the summary. Steps 1, 2,
    and 4 must pass unconditionally.
  </action>
  <verify>
    <automated>
      cd /home/maxi/Documents/coding/Projects/Better-Shell && make test && echo "--- Unit tests passed ---" && zsh -i -c 'source ./better-shell.sh; typeset -f _bsh_precmd > /dev/null 2>&1 && echo "PASS: zsh hooks defined" || { echo "FAIL: zsh hooks missing"; exit 1; }' 2>&1
    </automated>
  </verify>
  <done>
    `make test` passes (all bash unit tests unchanged). Zsh subshell confirms `_bsh_precmd` and
    `bsh` are defined after sourcing. Bash subshell confirms `_bsh_precmd` and `preexec_functions`
    are present. The zsh early-exit bug is resolved.
  </done>
</task>

</tasks>

<verification>
1. `grep "_bsh_load_bash_preexec" better-shell.sh` shows the wrapper function present
2. `grep -n "return 1" better-shell.sh` shows bash-preexec's early return is inside the function (high line number, not lines 41-43 at file scope)
3. `make test` passes all existing tests — no regression in bash
4. `zsh -i -c 'source ./better-shell.sh; typeset -f _bsh_precmd'` prints the function body (not empty)
5. `zsh -i -c 'source ./better-shell.sh; typeset -f bsh'` prints the function body (not empty)
</verification>

<success_criteria>
- Makefile build target wraps bash-preexec in a guarded loader function
- better-shell.sh built output: bash-preexec section is inside a function, lib/ code follows at file scope
- `make test` still passes (no bash regression)
- Zsh sourcing of better-shell.sh defines _bsh_precmd, _bsh_preexec, and bsh functions
- The root cause (return 1 at file scope aborting zsh load) is eliminated
- User can proceed to complete UAT tests 3-12 manually in an interactive zsh session
</success_criteria>

<output>
After completion, create `.planning/phases/01-hook-infrastructure/01-03-SUMMARY.md`
</output>
