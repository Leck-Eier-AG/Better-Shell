---
phase: 01-hook-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/toggle.sh
  - lib/config.sh
  - better-shell.sh
  - tests/test_toggle.sh
  - .gitignore
autonomous: true
requirements: [HOOK-04]

must_haves:
  truths:
    - "Running `bsh off` sets _BSH_ENABLED=0 and prints 'Better Shell: off'"
    - "Running `bsh on` sets _BSH_ENABLED=1 and prints 'Better Shell: on'"
    - "Running `bsh status` prints current state including shell and enabled/disabled"
    - "Running `bsh off --persist` writes enabled=0 to config file"
    - "Running `bsh on --persist` writes enabled=1 to config file"
    - "Config file is read at load time, so persisted disable survives new shell sessions"
    - "`make build` produces a single better-shell.sh that works in both bash and zsh"
    - "Invalid subcommand prints usage to stderr and returns 1"
  artifacts:
    - path: "lib/toggle.sh"
      provides: "bsh() dispatcher function"
      exports: ["bsh"]
      contains: "bsh()"
    - path: "lib/config.sh"
      provides: "Config file read/write helpers"
      exports: ["_bsh_config_load", "_bsh_config_set"]
      contains: "_bsh_config_set"
    - path: "better-shell.sh"
      provides: "Built distributable — single file users source"
      min_lines: 50
    - path: ".gitignore"
      provides: "Ignore built output if desired"
  key_links:
    - from: "lib/toggle.sh"
      to: "lib/config.sh"
      via: "bsh on/off --persist calls _bsh_config_set"
      pattern: "_bsh_config_set"
    - from: "lib/header.sh"
      to: "lib/config.sh"
      via: "config loaded at startup after variable init"
      pattern: "_bsh_config_load"
    - from: "better-shell.sh"
      to: "all lib/ files + vendor"
      via: "make build concatenation"
      pattern: "cat.*vendor.*lib"
---

<objective>
Implement the `bsh` toggle command with persistent config, build the distributable better-shell.sh, and validate the complete plugin end-to-end.

Purpose: Users need `bsh on/off/status` to control the plugin, and `--persist` to survive sessions. The built `better-shell.sh` is what users actually source — this plan produces the shippable artifact.
Output: lib/toggle.sh, lib/config.sh, built better-shell.sh, test suite for toggle/config, .gitignore.
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-hook-infrastructure/01-CONTEXT.md
@.planning/phases/01-hook-infrastructure/01-RESEARCH.md
@.planning/phases/01-hook-infrastructure/01-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 — key variables and functions the toggle/config code depends on -->

From lib/header.sh:
```bash
_BSH_LOADED=1
_BSH_DIR="${_BSH_DIR:-${HOME}/.better-shell}"
_BSH_VERSION="0.1.0"
_BSH_ENABLED=1
_BSH_SSH_ENABLED=0
```

From lib/hooks.sh:
```bash
_bsh_preexec()  # Registered in preexec_functions / add-zsh-hook
_bsh_precmd()   # Registered in precmd_functions / add-zsh-hook
_BSH_LAST_EXIT  # Set by _bsh_precmd
_BSH_LAST_CMD   # Set by _bsh_preexec
_BSH_CMD_DURATION # Set by _bsh_precmd
```

From lib/compat.sh:
```bash
_BSH_SHELL  # "bash" or "zsh"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement config read/write and bsh toggle dispatcher</name>
  <files>
    lib/config.sh
    lib/toggle.sh
  </files>
  <action>
    **lib/config.sh — Config file helpers:**

    Define `_bsh_config_load()`:
    - Config path: `"${_BSH_DIR}/config"` (simple key=value file, not TOML — TOML is Phase 4)
    - If config file doesn't exist, return 0 (no config is fine)
    - Read line by line with `while IFS='=' read -r key value`
    - Safety: skip lines where key doesn't match `^[a-zA-Z_][a-zA-Z0-9_]*$` (prevents injection)
    - Map known keys to variables:
      - `enabled` -> `_BSH_ENABLED="$value"`
      - `ssh_enabled` -> `_BSH_SSH_ENABLED="$value"`
    - Unknown keys are silently ignored (forward-compatible for Phase 2+ settings)

    Define `_bsh_config_set()`:
    - Takes key and value as arguments
    - Config path: `"${_BSH_DIR}/config"`
    - Create `_BSH_DIR` directory if it doesn't exist: `mkdir -p "${_BSH_DIR}"`
    - If config file exists: read it, filter out the existing key line, append new key=value
    - If config file doesn't exist: create it with just the one key=value line
    - Use atomic write pattern: write to temp file, then mv (prevents corruption)
      ```
      local tmp="${config}.tmp.$$"
      # write to tmp
      mv "$tmp" "$config"
      ```

    Call `_bsh_config_load` at the bottom of config.sh (so it runs when sourced, loading persisted state before env checks and hook registration).

    IMPORTANT: config.sh must be sourced AFTER header.sh (which sets defaults) but BEFORE env.sh (which uses _BSH_SSH_ENABLED). Update the Makefile concatenation order if needed:
    `vendor/bash-preexec.sh lib/header.sh lib/config.sh lib/env.sh lib/compat.sh lib/hooks.sh lib/toggle.sh`

    **lib/toggle.sh — bsh() dispatcher function:**

    Define `bsh()`:
    ```
    bsh() {
      local subcmd="${1:-}"
      local flag="${2:-}"
      case "$subcmd" in
        on)
          _BSH_ENABLED=1
          [[ "$flag" == "--persist" ]] && _bsh_config_set "enabled" "1"
          printf 'Better Shell: on\n'
          ;;
        off)
          _BSH_ENABLED=0
          [[ "$flag" == "--persist" ]] && _bsh_config_set "enabled" "0"
          printf 'Better Shell: off\n'
          ;;
        status)
          _bsh_print_status
          ;;
        *)
          printf 'Usage: bsh on|off|status [--persist]\n' >&2
          return 1
          ;;
      esac
    }
    ```

    Define `_bsh_print_status()`:
    - Print enabled/disabled state based on `_BSH_ENABLED`
    - Print detected shell from `_BSH_SHELL`
    - Print audio tool from `_BSH_AUDIO_TOOL` (default: "not detected" — Phase 2 will set this)
    - Print theme from `_BSH_THEME` (default: "default" — Phase 3 will set this)
    - Print version from `_BSH_VERSION`
    - Use `printf` not `echo` for portability

    The `bsh` function must be available in the user's shell after sourcing — it is NOT prefixed with underscore because it's the public API.
  </action>
  <verify>
    <automated>cd /home/maxi/Documents/coding/Projects/Better-Shell && test -f lib/config.sh && test -f lib/toggle.sh && grep -q "_bsh_config_load" lib/config.sh && grep -q "_bsh_config_set" lib/config.sh && grep -q "^bsh()" lib/toggle.sh && grep -q "_bsh_print_status" lib/toggle.sh && grep -q "\-\-persist" lib/toggle.sh && echo "PASS: config.sh and toggle.sh have expected functions"</automated>
  </verify>
  <done>
    lib/config.sh has _bsh_config_load (reads key=value config) and _bsh_config_set (atomic write). lib/toggle.sh has bsh() dispatcher with on/off/status subcommands, --persist flag support, and _bsh_print_status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build distributable, create .gitignore, and write toggle/config tests</name>
  <files>
    better-shell.sh
    .gitignore
    tests/test_toggle.sh
    Makefile
  </files>
  <action>
    **Update Makefile concatenation order** (if not already correct from Plan 01):
    The correct order is: `vendor/bash-preexec.sh lib/header.sh lib/config.sh lib/env.sh lib/compat.sh lib/hooks.sh lib/toggle.sh`
    - config.sh MUST come after header.sh (needs _BSH_DIR) and BEFORE env.sh (env.sh uses _BSH_SSH_ENABLED which config may set)
    - Add `make test` target: `bash tests/test_hooks.sh && bash tests/test_toggle.sh`

    **Run `make build`** to produce `better-shell.sh`.

    **.gitignore:**
    ```
    # Built distributable (regenerated via make build)
    # Uncomment if you want to track the built file:
    # better-shell.sh
    ```
    Note: Actually, we SHOULD track better-shell.sh in git so users who `git clone` get it immediately without needing make. So do NOT gitignore better-shell.sh. Instead, .gitignore should contain:
    ```
    # Editor/OS files
    *.swp
    *~
    .DS_Store

    # Config files (user-specific, created at runtime)
    config
    ```

    **tests/test_toggle.sh — Test suite for toggle and config:**

    Test structure: same TAP-style as test_hooks.sh.

    Since toggle/config are pure functions (no interactive requirement), we can test them directly by sourcing the lib files in order.

    Source files for testing (skip the interactive guard in env.sh by defining functions directly or by setting up the needed variables manually):
    ```bash
    # Set up minimal environment for testing
    _BSH_DIR="$(mktemp -d)"  # Use temp dir for config file tests
    _BSH_ENABLED=1
    _BSH_SSH_ENABLED=0
    _BSH_SHELL="bash"
    _BSH_VERSION="0.1.0"
    source lib/config.sh  # But skip the auto-call to _bsh_config_load if it runs
    source lib/toggle.sh
    ```

    Test cases:

    1. **bsh on/off toggles _BSH_ENABLED:** Call `bsh off`, verify `_BSH_ENABLED == 0`. Call `bsh on`, verify `_BSH_ENABLED == 1`.

    2. **bsh off output:** Capture output of `bsh off`, verify it equals "Better Shell: off".

    3. **bsh on output:** Capture output of `bsh on`, verify it equals "Better Shell: on".

    4. **bsh status output:** Call `bsh status`, verify output contains "enabled" or "disabled" and shell name.

    5. **bsh invalid subcommand:** Call `bsh foobar`, verify return code is 1 and stderr contains "Usage".

    6. **bsh no arguments:** Call `bsh`, verify return code is 1.

    7. **Config persist — bsh off --persist:** Call `bsh off --persist`, verify `${_BSH_DIR}/config` file exists and contains `enabled=0`.

    8. **Config persist — bsh on --persist:** Call `bsh on --persist`, verify config file contains `enabled=1` (and `enabled=0` line is gone).

    9. **Config load:** Write `enabled=0` to `${_BSH_DIR}/config`, call `_bsh_config_load`, verify `_BSH_ENABLED == 0`.

    10. **Config load — SSH enabled:** Write `ssh_enabled=1` to config, call `_bsh_config_load`, verify `_BSH_SSH_ENABLED == 1`.

    11. **Config safety — malformed lines:** Write `bad line!` and `=nokey` to config, call `_bsh_config_load`, verify no errors and variables unchanged.

    12. **Config atomic write:** Verify _bsh_config_set doesn't leave .tmp files behind.

    Cleanup: `rm -rf "$_BSH_DIR"` at end.

    After tests are written, run `make build` and then `make test` to verify everything works end to end.
  </action>
  <verify>
    <automated>cd /home/maxi/Documents/coding/Projects/Better-Shell && make build && make test</automated>
  </verify>
  <done>
    `make build` produces better-shell.sh (single distributable file). `make test` runs both test_hooks.sh and test_toggle.sh, all tests pass. .gitignore is set up. Config persistence works: bsh off --persist writes to config file, new shell session reads it back. Toggle correctly controls _BSH_ENABLED. Invalid commands return error with usage.
  </done>
</task>

</tasks>

<verification>
1. `make build` produces better-shell.sh without errors
2. better-shell.sh contains bash-preexec code followed by all lib/ files in correct order
3. `make test` passes all tests in test_hooks.sh and test_toggle.sh
4. `bsh on/off/status` work correctly in manual bash testing
5. `bsh off --persist` creates config file, `bsh on --persist` updates it
6. Config is read at load time (persisted state survives sessions)
7. better-shell.sh can be sourced in an interactive bash shell without errors
</verification>

<success_criteria>
- lib/toggle.sh has working bsh() dispatcher with on/off/status and --persist
- lib/config.sh has _bsh_config_load and _bsh_config_set with atomic writes and safety checks
- better-shell.sh is built and contains all components in correct order
- All tests pass via `make test`
- The complete Phase 1 plugin: source one file, hooks detect commands, bsh controls the plugin
</success_criteria>

<output>
After completion, create `.planning/phases/01-hook-infrastructure/01-02-SUMMARY.md`
</output>
