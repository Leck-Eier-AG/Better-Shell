---
phase: 02-audio
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - sounds/meme/error/light.wav
  - sounds/meme/error/medium.wav
  - sounds/meme/error/heavy.wav
  - sounds/meme/success/light.wav
  - sounds/meme/success/medium.wav
  - sounds/meme/success/heavy.wav
  - sounds/meme/warning/light.wav
  - sounds/meme/warning/medium.wav
  - sounds/meme/warning/heavy.wav
  - sounds/chill/error/light.wav
  - sounds/chill/success/light.wav
  - sounds/chill/warning/light.wav
  - sounds/retro/error/light.wav
  - sounds/retro/success/light.wav
  - sounds/retro/warning/light.wav
  - sounds/SOURCES.txt
  - lib/audio.sh
  - lib/hooks.sh
  - lib/toggle.sh
  - tests/test_audio.sh
autonomous: false
requirements: [AUD-03, AUD-04, AUD-09, AUD-10]

must_haves:
  truths:
    - "Plugin ships with 3 sound packs (meme, chill, retro) each containing error/success/warning sounds at 3 intensity tiers"
    - "User can drop .wav or .mp3 files into ~/.config/better-shell/sounds/{error,success,warning}/ and hear them instead of bundled sounds"
    - "User can switch active sound pack via bsh sound-pack <name>"
    - "User can create a custom pack by placing a folder with error/success/warning subdirs in the packs directory"
    - "Commands that succeed with stderr output trigger the warning sound (distinct from error)"
    - "All bundled sounds have documented CC0/public-domain licensing in SOURCES.txt"
  artifacts:
    - path: "sounds/meme/error/light.wav"
      provides: "Default meme pack light error sound"
    - path: "sounds/SOURCES.txt"
      provides: "License and source documentation for all bundled sounds"
    - path: "lib/toggle.sh"
      provides: "bsh sound-pack subcommand"
      contains: "sound-pack"
  key_links:
    - from: "lib/audio.sh (_bsh_resolve_sound)"
      to: "sounds/ directory"
      via: "file path resolution with glob"
      pattern: "_BSH_DIR.*sounds.*_BSH_SOUND_PACK"
    - from: "lib/hooks.sh (_bsh_preexec)"
      to: "lib/audio.sh (_bsh_audio_trigger)"
      via: "stderr capture setup in preexec, check in trigger"
      pattern: "_BSH_STDERR"
    - from: "lib/toggle.sh (bsh)"
      to: "_BSH_SOUND_PACK variable"
      via: "bsh sound-pack command sets variable and persists"
      pattern: "sound-pack"
---

<objective>
Bundle 3 sound packs with CC0-licensed sounds, implement custom sound workflow, pack switching, stderr detection for warning triggers, and hot reload.

Purpose: After this plan, the plugin ships working sounds out of the box with 3 thematic packs. Users can customize by dropping files into a directory or creating their own packs. Commands that produce stderr output trigger a distinct warning sound. The audio system is complete and production-ready.

Output: sounds/ directory with 3 packs, SOURCES.txt manifest, stderr detection in hooks, bsh sound-pack command, extended tests
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio/02-RESEARCH.md
@.planning/phases/02-audio/02-01-SUMMARY.md

<interfaces>
<!-- From Plan 02-01 (audio engine created there) -->

From lib/audio-player.sh:
```sh
_bsh_detect_audio_player()  # sets _BSH_AUDIO_TOOL
_bsh_play_sound()           # non-blocking playback, takes file path
```

From lib/audio.sh:
```sh
_BSH_AUDIO_THRESHOLD  # seconds, default 1
_BSH_SOUND_PACK       # active pack name, default "meme"
_BSH_SCALING_METHOD   # "duration" or "command-type"
_BSH_BLACKLIST_PATTERNS  # array of ERE patterns
_BSH_WHITELIST_PATTERNS  # array of ERE patterns

_bsh_audio_trigger()    # called from precmd, dispatches playback
_bsh_is_blacklisted()   # checks command name against blacklist
_bsh_in_whitelist()     # checks command name against whitelist
_bsh_get_intensity()    # maps duration to light/medium/heavy
_bsh_resolve_sound()    # resolves event+intensity to file path
```

From lib/hooks.sh:
```sh
_bsh_preexec()  # records _BSH_CMD_START_TIME and _BSH_LAST_CMD
_bsh_precmd()   # captures exit code, calculates duration, calls _bsh_audio_trigger
```

From lib/toggle.sh:
```sh
bsh()  # public dispatcher with case statement for on/off/status subcommands
```

From lib/config.sh:
```sh
_bsh_config_load()  # reads key=value; maps audio_threshold, sound_pack, volume, scaling_method
_bsh_config_set()   # atomic write key=value
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bundled sound packs and source manifest</name>
  <files>sounds/meme/error/light.wav, sounds/meme/error/medium.wav, sounds/meme/error/heavy.wav, sounds/meme/success/light.wav, sounds/meme/success/medium.wav, sounds/meme/success/heavy.wav, sounds/meme/warning/light.wav, sounds/meme/warning/medium.wav, sounds/meme/warning/heavy.wav, sounds/chill/error/light.wav, sounds/chill/error/medium.wav, sounds/chill/error/heavy.wav, sounds/chill/success/light.wav, sounds/chill/success/medium.wav, sounds/chill/success/heavy.wav, sounds/chill/warning/light.wav, sounds/chill/warning/medium.wav, sounds/chill/warning/heavy.wav, sounds/retro/error/light.wav, sounds/retro/error/medium.wav, sounds/retro/error/heavy.wav, sounds/retro/success/light.wav, sounds/retro/success/medium.wav, sounds/retro/success/heavy.wav, sounds/retro/warning/light.wav, sounds/retro/warning/medium.wav, sounds/retro/warning/heavy.wav, sounds/SOURCES.txt</files>
  <action>
**Directory structure:** Create 3 packs (meme, chill, retro), each with 3 categories (error, success, warning), each with 3 intensity tiers (light, medium, heavy). Total: 27 sound files.

```
sounds/
├── meme/
│   ├── error/{light,medium,heavy}.wav
│   ├── success/{light,medium,heavy}.wav
│   └── warning/{light,medium,heavy}.wav
├── chill/
│   ├── error/{light,medium,heavy}.wav
│   ├── success/{light,medium,heavy}.wav
│   └── warning/{light,medium,heavy}.wav
├── retro/
│   ├── error/{light,medium,heavy}.wav
│   ├── success/{light,medium,heavy}.wav
│   └── warning/{light,medium,heavy}.wav
└── SOURCES.txt
```

**Sound sourcing strategy:** Use `sox` (SoX - Sound eXchange) to generate synthesized sounds. SoX is widely available and can create tones, noise bursts, and effects entirely from the command line with no external audio files needed. This sidesteps all licensing concerns — generated sounds are original works.

Check if sox is available: `command -v sox`. If not available, use Python's wave module as fallback, or as last resort create minimal valid WAV files using printf/dd (44-byte header + raw PCM data).

**Sound design per pack:**

Meme pack (dramatic, over-the-top):
- Error: Descending tone + distortion. Light = short buzz, Medium = longer descending, Heavy = dramatic low rumble
- Success: Ascending fanfare tone. Light = quick blip, Medium = triumphant rise, Heavy = full ascending chord
- Warning: Wobble/alarm tone. Light = quick wobble, Medium = sustained wobble, Heavy = urgent alarm

Chill pack (soft, satisfying):
- Error: Soft low tone. Light = gentle thud, Medium = mellow buzz, Heavy = deep bass note
- Success: Pleasant chime. Light = single ding, Medium = double chime, Heavy = harmony chord
- Warning: Subtle notification. Light = soft click, Medium = gentle ping, Heavy = warm alert

Retro pack (8-bit, chiptune):
- Error: Square wave descend. Light = quick blip down, Medium = descending scale, Heavy = crash sequence
- Success: Square wave ascend. Light = coin sound, Medium = level-up, Heavy = victory jingle
- Warning: Triangle wave pulse. Light = alert pip, Medium = warning beep, Heavy = alarm sequence

**Sox commands (examples — adjust frequencies and durations for character):**

```sh
# Meme error light: short descending buzz (0.3s)
sox -n sounds/meme/error/light.wav synth 0.3 sine 400:200 gain -10

# Meme error heavy: dramatic long descend (1.2s)
sox -n sounds/meme/error/heavy.wav synth 1.2 sine 600:80 overdrive 20 gain -8

# Retro success light: coin-like blip (0.15s)
sox -n sounds/retro/success/light.wav synth 0.15 square 800 synth 0.15 square 1200 gain -12

# Chill success light: gentle chime (0.4s)
sox -n sounds/chill/success/light.wav synth 0.4 sine 880 fade 0.05 0.4 0.2 gain -15
```

Generate all 27 files with distinct character matching each pack's personality and each intensity tier's weight. Keep files SHORT: light = 0.1-0.3s, medium = 0.3-0.7s, heavy = 0.7-1.5s. This prevents audio from becoming annoying.

If sox is NOT available: install it via the system package manager (`sudo pacman -S sox` on Manjaro/Arch), OR create a Python script that generates WAV files using the `wave` and `struct` modules (no external dependencies). The Python approach generates sine/square waves at specified frequencies and durations.

**Create `sounds/SOURCES.txt`:**
```
# Better Shell — Sound Sources
# All sounds in this directory are original synthesized works.
# Generated using SoX (Sound eXchange) — no copyrighted material.
# License: CC0 1.0 Universal (Public Domain Dedication)
# https://creativecommons.org/publicdomain/zero/1.0/
#
# Pack: meme — dramatic, over-the-top synthesized tones
# Pack: chill — soft, pleasant synthesized chimes
# Pack: retro — 8-bit style square/triangle wave tones
#
# Generation date: 2026-02-26
# Tool: sox -n <output> synth <duration> <waveform> <freq> [effects]
```

**Verify:** All 27 .wav files exist and are playable:
```sh
find sounds/ -name "*.wav" | wc -l  # should be 27
pw-play sounds/meme/error/light.wav  # quick listen test
```
  </action>
  <verify>
    <automated>test $(find sounds/ -name "*.wav" | wc -l) -eq 27 && test -f sounds/SOURCES.txt && echo "27 sounds + manifest OK"</automated>
  </verify>
  <done>27 WAV files exist across 3 packs x 3 categories x 3 intensities; SOURCES.txt documents CC0 licensing; sounds are playable and distinct per pack/category/intensity</done>
</task>

<task type="auto">
  <name>Task 2: Implement stderr detection, pack switching, hot reload, and extend tests</name>
  <files>lib/hooks.sh, lib/audio.sh, lib/toggle.sh, lib/config.sh, tests/test_audio.sh</files>
  <action>
**Stderr detection (AUD-10):**

Modify `lib/hooks.sh` `_bsh_preexec` to set up stderr capture:

```sh
# In _bsh_preexec, after recording _BSH_LAST_CMD:
# Stderr detection: create temp file, redirect stderr through tee
if [[ "${_BSH_STDERR_DETECT:-0}" == "1" ]]; then
  _BSH_STDERR_FILE="${TMPDIR:-/tmp}/bsh_stderr.$$"
  : > "$_BSH_STDERR_FILE"  # truncate/create
  exec 9>&2                # save original stderr to fd 9 (fixed, not dynamic — bash 3.x compat)
  exec 2> >(tee -a "$_BSH_STDERR_FILE" >&9)  # tee stderr to file AND original
fi
```

Modify `lib/hooks.sh` `_bsh_precmd` to check and clean up stderr capture (BEFORE _bsh_audio_trigger call):

```sh
# Stderr detection: check captured output and clean up
_BSH_LAST_STDERR=""
if [[ "${_BSH_STDERR_DETECT:-0}" == "1" && -f "${_BSH_STDERR_FILE:-}" ]]; then
  [[ -s "$_BSH_STDERR_FILE" ]] && _BSH_LAST_STDERR="1"  # non-empty = has stderr
  rm -f "$_BSH_STDERR_FILE"
  exec 2>&9 9>&-  # restore stderr, close saved fd
fi
```

**IMPORTANT:** `_BSH_STDERR_DETECT` defaults to 0 (OFF). This feature is opt-in because the `exec 2> >(tee ...)` pattern adds a background process per command and can be fragile. Users enable it via `_BSH_STDERR_DETECT=1` in config or environment. When off, `_BSH_LAST_STDERR` is always empty, so warning sounds never trigger — only error and success.

Add `stderr_detect` to `lib/config.sh` case statement:
```sh
      stderr_detect) _BSH_STDERR_DETECT="$value" ;;
```

Set default at top of `lib/audio.sh`:
```sh
_BSH_STDERR_DETECT="${_BSH_STDERR_DETECT:-0}"
```

**Pack switching (AUD-09):**

Modify `lib/toggle.sh` to add `sound-pack` subcommand to the `bsh()` function's case statement:

```sh
    sound-pack)
      if [[ -z "${2:-}" ]]; then
        echo "Active pack: ${_BSH_SOUND_PACK:-meme}"
        echo "Available packs:"
        # List bundled packs
        local p
        for p in "${_BSH_DIR}"/sounds/*/; do
          [[ -d "$p" ]] && echo "  $(basename "$p")"
        done
        # List user packs
        local user_packs="${HOME}/.config/better-shell/packs"
        if [[ -d "$user_packs" ]]; then
          for p in "${user_packs}"/*/; do
            [[ -d "$p" ]] && echo "  $(basename "$p") (user)"
          done
        fi
      else
        _BSH_SOUND_PACK="$2"
        _bsh_config_set sound_pack "$2"
        echo "Sound pack set to: $2"
      fi
      ;;
```

Also add `volume` subcommand:
```sh
    volume)
      if [[ -z "${2:-}" ]]; then
        echo "Volume: ${_BSH_VOLUME:-70}"
      else
        _BSH_VOLUME="$2"
        _bsh_config_set volume "$2"
        echo "Volume set to: $2"
      fi
      ;;
```

Update the usage/help text in the `*` catch-all case to include `sound-pack` and `volume`.

**Custom sound resolution (AUD-04) — update _bsh_resolve_sound in lib/audio.sh:**

The function already checks user drop-in directory and bundled pack. Ensure it also checks user-created packs:

Resolution order:
1. User drop-in override: `~/.config/better-shell/sounds/${event}/${intensity}.*`
2. User custom pack (if active pack matches a user pack): `~/.config/better-shell/packs/${_BSH_SOUND_PACK}/${event}/${intensity}.*`
3. Bundled pack: `${_BSH_DIR}/sounds/${_BSH_SOUND_PACK}/${event}/${intensity}.*`

Update the function to include step 2.

**Hot reload (config mtime check):**

Add `_bsh_audio_config_check` to `lib/audio.sh`:
```sh
_bsh_audio_config_check() {
  local config="${_BSH_DIR}/config"
  [[ -f "$config" ]] || return 0
  local current_mtime
  current_mtime=$(stat -c %Y "$config" 2>/dev/null || stat -f %m "$config" 2>/dev/null || echo "0")
  [[ "$current_mtime" == "${_BSH_CONFIG_MTIME:-}" ]] && return 0
  _BSH_CONFIG_MTIME="$current_mtime"
  _bsh_config_load
}
```

Call `_bsh_audio_config_check` at the TOP of `_bsh_audio_trigger` (before any decision logic). This makes config changes (blacklist, whitelist, volume, pack, threshold) take effect immediately without re-sourcing.

**Extend tests/test_audio.sh** with additional tests:

21. **Stderr variable defaults to empty:** `[[ -z "${_BSH_LAST_STDERR:-}" ]]`
22. **Pack switching sets variable:** `bsh sound-pack retro` then `[[ "$_BSH_SOUND_PACK" == "retro" ]]`
23. **Sound resolution finds bundled file:** Set `_BSH_SOUND_PACK=meme`, `_BSH_DIR` to project root. `_bsh_resolve_sound "error" "light"` returns non-empty string ending in .wav
24. **Sound resolution returns empty for nonexistent pack:** `_BSH_SOUND_PACK=nonexistent; _bsh_resolve_sound "error" "light"` returns ""
25. **Volume subcommand:** `bsh volume 50` then `[[ "$_BSH_VOLUME" == "50" ]]`
26. **Config hot reload function exists:** `declare -f _bsh_audio_config_check` returns 0
27. **Intensity tier boundaries correct:** `_bsh_get_intensity 4` = "light", `_bsh_get_intensity 5` = "medium", `_bsh_get_intensity 30` = "heavy"
28. **Trigger fires warning when stderr present:** Set `_BSH_LAST_STDERR=1`, `_BSH_LAST_EXIT=0`, `_BSH_CMD_DURATION=5`. Mock `_bsh_resolve_sound`. Verify event="warning" is passed.

Update test count in header and footer.
  </action>
  <verify>
    <automated>make build && bash tests/test_audio.sh && make test</automated>
  </verify>
  <done>Stderr detection works (opt-in via _BSH_STDERR_DETECT=1); bsh sound-pack and bsh volume commands work; config hot reload checks mtime on each precmd; 28+ audio tests pass; make test passes all suites</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify audio feedback works end-to-end</name>
  <files>better-shell.sh</files>
  <action>
Human verifies the complete audio subsystem works correctly in a live shell session.

What was built: Complete audio subsystem with 3 sound packs, non-blocking playback, threshold/blacklist filtering, custom sound support, and stderr-based warning triggers.

Steps to verify:
1. Source the plugin: `source better-shell.sh`
2. Run a failing command: `ls /nonexistent` — you should hear the meme error sound (light intensity since it's fast)
3. Run a longer failing command: `sleep 6 && false` — you should hear a medium-intensity error sound
4. Run a successful command: `sleep 2` — you should hear a success sound
5. Run a fast command: `echo hello` — no sound (under threshold)
6. Run a blacklisted command: `man ls` then quit — no sound
7. Switch packs: `bsh sound-pack retro` then `ls /nonexistent` — should hear a different (8-bit style) error sound
8. Check volume: `bsh volume 30` then trigger a sound — should be quieter
9. Check status: `bsh status` — should show audio tool and current pack
10. Verify no "[1]+ Done" messages appear after sounds finish playing
  </action>
  <verify>
    <automated>make test</automated>
  </verify>
  <done>User confirms audio plays correctly: error sounds on failures, success sounds on successes, no sound on fast/blacklisted commands, pack switching works, volume control works, no job control messages visible</done>
</task>

</tasks>

<verification>
1. `find sounds/ -name "*.wav" | wc -l` returns 27
2. `cat sounds/SOURCES.txt` shows CC0 licensing
3. `make build` succeeds
4. `make test` passes all test suites (hooks + toggle + audio)
5. `bash tests/test_audio.sh` passes 28+ tests
6. `grep "sound-pack" lib/toggle.sh` confirms subcommand exists
7. `grep "_BSH_STDERR" lib/hooks.sh` confirms stderr detection code
</verification>

<success_criteria>
- 3 bundled sound packs with 27 total WAV files, all CC0 licensed
- `bsh sound-pack <name>` switches active pack and persists
- `bsh volume <0-100>` sets volume and persists
- Custom sounds via drop-in directory override bundled sounds
- Stderr detection is opt-in (_BSH_STDERR_DETECT=1) and triggers warning category
- Hot reload: config changes take effect without re-sourcing
- All tests pass, all sounds are audible and appropriate for their category
</success_criteria>

<output>
After completion, create `.planning/phases/02-audio/02-02-SUMMARY.md`
</output>
