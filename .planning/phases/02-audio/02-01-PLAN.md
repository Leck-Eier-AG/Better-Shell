---
phase: 02-audio
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/audio-player.sh
  - lib/audio.sh
  - lib/hooks.sh
  - Makefile
  - tests/test_audio.sh
autonomous: true
requirements: [AUD-01, AUD-02, AUD-05, AUD-06, AUD-07, AUD-08]

must_haves:
  truths:
    - "Running a failing command triggers _bsh_audio_trigger with event=error"
    - "Running a successful command triggers _bsh_audio_trigger with event=success"
    - "Commands under the time threshold (500ms default) produce no audio trigger"
    - "Blacklisted commands (vim, man, ssh, etc.) produce no audio trigger"
    - "Whitelisted commands override both threshold and blacklist"
    - "Audio playback is non-blocking — the next prompt appears immediately"
    - "Plugin detects the available audio player (pw-play/paplay/afplay/aplay) at load time"
    - "Systems with no audio player silently no-op"
  artifacts:
    - path: "lib/audio-player.sh"
      provides: "Player detection, volume normalization, non-blocking playback"
      exports: ["_bsh_detect_audio_player", "_bsh_play_sound", "_bsh_vol_afplay", "_bsh_vol_pw", "_bsh_vol_paplay"]
    - path: "lib/audio.sh"
      provides: "Trigger logic, blacklist/whitelist, intensity calculation, sound resolution"
      exports: ["_bsh_audio_trigger", "_bsh_is_blacklisted", "_bsh_in_whitelist", "_bsh_get_intensity", "_bsh_resolve_sound"]
    - path: "tests/test_audio.sh"
      provides: "TAP-style integration tests for audio subsystem"
      min_lines: 80
  key_links:
    - from: "lib/hooks.sh"
      to: "lib/audio.sh"
      via: "_bsh_audio_trigger called at end of _bsh_precmd"
      pattern: "_bsh_audio_trigger"
    - from: "lib/audio.sh"
      to: "lib/audio-player.sh"
      via: "_bsh_play_sound called from _bsh_audio_trigger"
      pattern: "_bsh_play_sound"
    - from: "lib/audio-player.sh"
      to: "system audio player"
      via: "_BSH_AUDIO_TOOL detected at load time"
      pattern: "_BSH_AUDIO_TOOL"
---

<objective>
Build the core audio playback engine, trigger decision logic, and wire it into the existing precmd hook infrastructure.

Purpose: This plan creates the entire audio subsystem from player detection through trigger firing. After this plan, running commands will trigger audio playback decisions based on exit code, duration threshold, and blacklist/whitelist rules. The playback is non-blocking and cross-platform.

Output: lib/audio-player.sh (playback engine), lib/audio.sh (trigger logic), modified lib/hooks.sh (precmd integration), updated Makefile, tests/test_audio.sh
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio/02-RESEARCH.md

<interfaces>
<!-- Key variables and functions from Phase 1 that this plan depends on -->

From lib/header.sh:
```sh
_BSH_DIR="${_BSH_DIR:-${HOME}/.better-shell}"
_BSH_ENABLED=1
```

From lib/hooks.sh:
```sh
_bsh_preexec() {
  [[ -n "${ZSH_VERSION:-}" ]] && emulate -L zsh
  [[ $_BSH_ENABLED == 1 ]] || return 0
  _BSH_CMD_START_TIME=$SECONDS
  _BSH_LAST_CMD="${1:-}"
}

_bsh_precmd() {
  local _bsh_exit=$?
  [[ $_BSH_ENABLED == 1 ]] || return 0
  _BSH_LAST_EXIT=$_bsh_exit
  _BSH_CMD_DURATION=$(( SECONDS - ${_BSH_CMD_START_TIME:-$SECONDS} ))
  _BSH_CMD_START_TIME=$SECONDS
  # Phase 2+ will act on _BSH_LAST_EXIT and _BSH_CMD_DURATION here
}
```

From lib/config.sh:
```sh
_bsh_config_load()  # reads key=value from ${_BSH_DIR}/config
_bsh_config_set()   # atomic write key=value to ${_BSH_DIR}/config
# case statement maps known keys to variables — extend for audio keys
```

From Makefile:
```makefile
LIB := lib/header.sh lib/config.sh lib/env.sh lib/compat.sh lib/hooks.sh lib/toggle.sh
EXISTING_LIB := $(wildcard $(LIB))
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audio player detection and non-blocking playback engine</name>
  <files>lib/audio-player.sh</files>
  <action>
Create `lib/audio-player.sh` with the following functions:

**_bsh_detect_audio_player():**
- Probe for players in preference order: pw-play > paplay > afplay > aplay
- Use `command -v "$p" >/dev/null 2>&1` for each
- Store result in `_BSH_AUDIO_TOOL` (empty string = no audio = silent no-op)
- Called once at load time (bottom of audio-player.sh, guarded by _BSH_ENABLED)

**Volume normalization functions:**
- `_bsh_vol_afplay()`: Takes 0-100 integer, outputs float 0.00-1.00 via awk
- `_bsh_vol_pw()`: Takes 0-100 integer, outputs float 0.00-1.00 via awk
- `_bsh_vol_paplay()`: Takes 0-100 integer, outputs integer 0-65536 via shell arithmetic `$(( $1 * 65536 / 100 ))`
- aplay has NO volume flag — omit entirely

**_bsh_play_sound():**
- Takes one argument: file path
- Guard: return 0 if `_BSH_AUDIO_TOOL` is empty, file is empty, or file doesn't exist
- Wrap playback in subshell with `set +m` to suppress job control messages
- Dispatch based on `_BSH_AUDIO_TOOL` (case statement: pw-play, paplay, afplay, aplay)
- Each case passes the appropriate volume flag using the normalization function with `${_BSH_VOLUME:-70}` as default
- aplay case: `aplay -q "$file" >/dev/null 2>&1` (no volume flag)
- All cases redirect stdout/stderr to /dev/null
- Background the subshell with `&` and `disown $! 2>/dev/null`

**Default variables (set at top of file):**
- `_BSH_VOLUME="${_BSH_VOLUME:-70}"` — default volume 0-100
- `_BSH_AUDIO_TOOL=""` — set by detection

**At bottom of file:** Call `_bsh_detect_audio_player` (runs at source time, one-time detection).

IMPORTANT: Do NOT use `[[ ]]` without explicit `local` for awk subshells — awk output goes to stdout, use command substitution in the case branches directly.
  </action>
  <verify>
    <automated>bash -n lib/audio-player.sh && echo "syntax OK"</automated>
  </verify>
  <done>lib/audio-player.sh exists, passes bash -n syntax check, contains _bsh_detect_audio_player, _bsh_play_sound, three volume functions, and calls detection at bottom</done>
</task>

<task type="auto">
  <name>Task 2: Create audio trigger logic, integrate into precmd, and update build</name>
  <files>lib/audio.sh, lib/hooks.sh, lib/config.sh, Makefile</files>
  <action>
**Create `lib/audio.sh`** with the following functions:

**Default variables (top of file):**
```sh
_BSH_AUDIO_THRESHOLD="${_BSH_AUDIO_THRESHOLD:-1}"  # seconds (500ms rounds to 1s since SECONDS is integer)
_BSH_SOUND_PACK="${_BSH_SOUND_PACK:-meme}"
_BSH_SCALING_METHOD="${_BSH_SCALING_METHOD:-duration}"  # "duration" or "command-type"
```

Note on threshold: SECONDS is an integer in bash/zsh, so 500ms cannot be measured directly. Use 1 second as the default threshold. Document this — the 500ms user decision is honored as closely as integer seconds allow (0 duration = skip, 1+ = play).

**Blacklist/whitelist arrays:**
```sh
_BSH_BLACKLIST_PATTERNS=("^vim$" "^nvim$" "^nano$" "^emacs$" "^vi$" "^man$" "^less$" "^more$" "^watch$" "^top$" "^htop$" "^python" "^node$" "^irb$" "^psql$" "^mysql$" "^ssh$")
_BSH_WHITELIST_PATTERNS=()  # empty by default; user populates
```

Use arrays (bash 3.x+ and zsh both support them). Store as ERE patterns.

**_bsh_is_blacklisted():**
- Takes command name as $1
- Iterates `_BSH_BLACKLIST_PATTERNS` array
- Uses `[[ "$cmd_name" =~ $pattern ]]` — do NOT quote the pattern (bash disables regex when quoted)
- Returns 0 (true) if any pattern matches, 1 (false) otherwise

**_bsh_in_whitelist():**
- Same logic as blacklist but against `_BSH_WHITELIST_PATTERNS`
- Returns 0 if matched, 1 if not
- Empty array = nothing whitelisted (always returns 1)

**_bsh_get_intensity():**
- Takes duration in seconds as $1
- Duration-based (default): <5s = "light", 5-30s = "medium", >30s = "heavy"
- Returns intensity string via echo

**_bsh_resolve_sound():**
- Takes event ($1: error|success|warning) and intensity ($2: light|medium|heavy)
- Resolution order:
  1. User drop-in: `${HOME}/.config/better-shell/sounds/${event}/${intensity}.*` (check .wav then .mp3 then any glob match)
  2. Bundled pack: `${_BSH_DIR}/sounds/${_BSH_SOUND_PACK}/${event}/${intensity}.*` (same extension search)
- Echo the file path if found, empty string if not (silent no-op)
- Use glob with first-match: `local f; for f in "${dir}/${intensity}".*; do [[ -f "$f" ]] && echo "$f" && return 0; done`

**_bsh_audio_trigger():**
- Called from _bsh_precmd. No arguments — reads global variables.
- Guard: `[[ -z "${_BSH_AUDIO_TOOL:-}" ]] && return 0` (no player = silent)
- Extract command name: `local cmd_name="${_BSH_LAST_CMD%% *}"`
- Whitelist check first (overrides threshold and blacklist): `_bsh_in_whitelist "$cmd_name"` — if true, skip threshold and blacklist
- Otherwise: threshold check `[[ "${_BSH_CMD_DURATION:-0}" -lt "${_BSH_AUDIO_THRESHOLD:-1}" ]] && return 0`
- Blacklist check: `_bsh_is_blacklisted "$cmd_name" && return 0`
- Determine event type: if `_BSH_LAST_EXIT != 0` then "error"; elif `_BSH_LAST_STDERR` is non-empty then "warning"; else "success"
- Get intensity: `_bsh_get_intensity "${_BSH_CMD_DURATION:-0}"`
- Resolve sound file: `_bsh_resolve_sound "$event" "$intensity"`
- Play: `_bsh_play_sound "$sound_file"` (if non-empty)

**Modify `lib/hooks.sh`:**
- Add `_bsh_audio_trigger` call at the end of `_bsh_precmd`, AFTER `_BSH_CMD_DURATION` is calculated and BEFORE the start time reset
- Place it after the comment "Phase 2+ will act on..." — replace that comment with the actual call:
```sh
  # Audio feedback (Phase 2)
  _bsh_audio_trigger
```

**Modify `lib/config.sh`:**
- Extend the `case` statement in `_bsh_config_load` to handle new audio keys:
```sh
      audio_threshold) _BSH_AUDIO_THRESHOLD="$value" ;;
      sound_pack)      _BSH_SOUND_PACK="$value"      ;;
      volume)          _BSH_VOLUME="$value"           ;;
      scaling_method)  _BSH_SCALING_METHOD="$value"   ;;
```

**Modify `Makefile`:**
- Add `lib/audio-player.sh` and `lib/audio.sh` to the LIB list, AFTER lib/hooks.sh but BEFORE lib/toggle.sh:
```makefile
LIB := lib/header.sh lib/config.sh lib/env.sh lib/compat.sh lib/hooks.sh lib/audio-player.sh lib/audio.sh lib/toggle.sh
```
Wait — audio-player.sh must be sourced BEFORE hooks.sh because hooks.sh calls _bsh_audio_trigger which calls _bsh_play_sound. Actually no — hooks.sh just defines _bsh_precmd which CALLS _bsh_audio_trigger at runtime, not at parse time. So the order just needs both audio files sourced before the shell session starts using them. Place them after hooks.sh:
```makefile
LIB := lib/header.sh lib/config.sh lib/env.sh lib/compat.sh lib/hooks.sh lib/audio-player.sh lib/audio.sh lib/toggle.sh
```

- Add `tests/test_audio.sh` to the test target:
```makefile
test:
	bash tests/test_hooks.sh && bash tests/test_toggle.sh && bash tests/test_audio.sh
```
  </action>
  <verify>
    <automated>bash -n lib/audio.sh && bash -n lib/hooks.sh && bash -n lib/config.sh && make build && echo "all OK"</automated>
  </verify>
  <done>lib/audio.sh has trigger logic with blacklist/whitelist/threshold/intensity; lib/hooks.sh calls _bsh_audio_trigger in precmd; config.sh handles audio keys; Makefile includes both audio files and test</done>
</task>

<task type="auto">
  <name>Task 3: Create TAP-style integration tests for audio subsystem</name>
  <files>tests/test_audio.sh</files>
  <action>
Create `tests/test_audio.sh` following the same TAP-style pattern as `tests/test_hooks.sh` and `tests/test_toggle.sh`.

**Test scaffold:**
```sh
#!/usr/bin/env bash
# Tests for Better Shell audio subsystem
# TAP format: ok/not ok N - description

PASS=0 FAIL=0 TOTAL=0

pass() { TOTAL=$((TOTAL+1)); PASS=$((PASS+1)); echo "ok $TOTAL - $1"; }
fail() { TOTAL=$((TOTAL+1)); FAIL=$((FAIL+1)); echo "not ok $TOTAL - $1"; }

# Source the individual lib files in order (not the built file, for unit isolation)
source lib/header.sh
source lib/config.sh
source lib/env.sh 2>/dev/null || true  # may exit in non-interactive; ignore
source lib/compat.sh 2>/dev/null || true
source lib/hooks.sh
source lib/audio-player.sh
source lib/audio.sh
```

Actually, since env.sh gates on interactive, source lib files directly but skip env.sh (just like existing test files do). Check how test_hooks.sh sources:

Source only what's needed: header.sh, config.sh, hooks.sh, audio-player.sh, audio.sh. Skip env.sh and compat.sh (they gate on interactive).

**Tests to include (minimum 14):**

1. **Player detection function exists:** `declare -f _bsh_detect_audio_player` returns 0
2. **Play sound function exists:** `declare -f _bsh_play_sound` returns 0
3. **Audio trigger function exists:** `declare -f _bsh_audio_trigger` returns 0
4. **_BSH_AUDIO_TOOL is set after sourcing** (should find pw-play or paplay on this Linux machine)
5. **Volume normalization afplay:** `_bsh_vol_afplay 70` outputs "0.70"
6. **Volume normalization pw-play:** `_bsh_vol_pw 50` outputs "0.50"
7. **Volume normalization paplay:** `_bsh_vol_paplay 100` outputs "65536"
8. **Volume normalization paplay zero:** `_bsh_vol_paplay 0` outputs "0"
9. **Blacklist matches vim:** `_bsh_is_blacklisted "vim"` returns 0
10. **Blacklist matches python3:** `_bsh_is_blacklisted "python3"` returns 0 (pattern is `^python` — prefix match)
11. **Blacklist does NOT match ls:** `_bsh_is_blacklisted "ls"` returns 1
12. **Blacklist does NOT match git:** `_bsh_is_blacklisted "git"` returns 1
13. **Whitelist empty returns false:** `_bsh_in_whitelist "anything"` returns 1
14. **Intensity light:** `_bsh_get_intensity 2` outputs "light"
15. **Intensity medium:** `_bsh_get_intensity 15` outputs "medium"
16. **Intensity heavy:** `_bsh_get_intensity 60` outputs "heavy"
17. **Threshold blocks short commands:** Set `_BSH_CMD_DURATION=0`, `_BSH_LAST_EXIT=1`, `_BSH_LAST_CMD="ls"`, `_BSH_AUDIO_TOOL="test"`. Call `_bsh_audio_trigger`. Verify `_bsh_play_sound` was NOT called (mock it: `_bsh_play_sound() { PLAY_CALLED=1; }` then check PLAY_CALLED)
18. **Blacklist blocks vim:** Set `_BSH_CMD_DURATION=5`, `_BSH_LAST_EXIT=1`, `_BSH_LAST_CMD="vim foo.txt"`, `_BSH_AUDIO_TOOL="test"`. Call `_bsh_audio_trigger`. Verify play NOT called.
19. **Error trigger fires for failing command:** Set `_BSH_CMD_DURATION=5`, `_BSH_LAST_EXIT=1`, `_BSH_LAST_CMD="make build"`, `_BSH_AUDIO_TOOL="test"`. Mock `_bsh_play_sound() { PLAY_CALLED=1; PLAY_FILE="$1"; }`. Call `_bsh_audio_trigger`. Verify PLAY_CALLED=1.
20. **Resolve sound returns empty for missing files:** `_bsh_resolve_sound "error" "light"` with no sounds directory echoes ""

**Footer:**
```sh
echo "# $PASS/$TOTAL passed, $FAIL failed"
[[ $FAIL -eq 0 ]] && exit 0 || exit 1
```
  </action>
  <verify>
    <automated>bash tests/test_audio.sh</automated>
  </verify>
  <done>tests/test_audio.sh runs 20 tests, all pass; covers player detection, volume normalization, blacklist/whitelist, intensity, threshold blocking, and trigger dispatch</done>
</task>

</tasks>

<verification>
1. `bash -n lib/audio-player.sh` — no syntax errors
2. `bash -n lib/audio.sh` — no syntax errors
3. `make build` — produces better-shell.sh including audio files
4. `bash tests/test_audio.sh` — all 20 tests pass
5. `make test` — all tests pass (hooks + toggle + audio)
6. `grep "_bsh_audio_trigger" lib/hooks.sh` — trigger is called from precmd
</verification>

<success_criteria>
- Audio player detection runs at source time and stores result in _BSH_AUDIO_TOOL
- _bsh_play_sound fires audio asynchronously (& + disown) inside a subshell with set +m
- _bsh_audio_trigger evaluates threshold, blacklist, whitelist, exit code, and intensity before dispatching
- All 20 audio tests pass via `bash tests/test_audio.sh`
- `make build && make test` succeeds with all test suites
</success_criteria>

<output>
After completion, create `.planning/phases/02-audio/02-01-SUMMARY.md`
</output>
